name: 'Snack25 Backend Deploy' # 워크플로우 이름

on:
  push:
    branches:
      - main # 메인 브랜치에 push가 되면 deploy jobs 트리거(실행)

jobs:
  deploy-to-ec2-whenever-push-to-main:
    name: 'main 브랜치에 push가 되면 EC2로 배포하는 작업'
    runs-on: ubuntu-latest # 우분투(24.04.2) 환경에서 deploy jobs 실행

    steps:
      - name: Checkout Repository # 1. 레포지토리를 체크아웃
        uses: actions/checkout@v4 # actions/checkout 레포지토리의 v4 버전 사용

      - name: Setup Node.js # 2. Node.js 설정
        uses: actions/setup-node@v4 # actions/setup-node 레포지토리의 v4 버전 사용
        with:
          node-version: '22' # Node.js 버전 22 사용

      - name: Setup pnpm # pnpm 설정
        uses: pnpm/action-setup@v4 # pnpm/action-setup 레포지토리의 v4 버전 사용
        with:
          version: '10' # pnpm 버전 10 사용
          run_install: false # 이미 설치되어 있으므로 설치하지 않음

      - name: Cache dependencies # 의존성 캐싱
        uses: actions/cache@v4 # actions/cache 레포지토리의 v4 버전 사용
        with:
          path: |
            ~/.pnpm-store
            node_modules
            .pnpm-store  # pnpm store 디렉토리 추가
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }} # 캐시 키 설정
          restore-keys: |
            ${{ runner.os }}-pnpm- # 캐시 키 복원

      - name: Install Dependencies
        run: pnpm install --frozen-lockfile --ignore-scripts # 빌드에 필요한 devDependencies도 설치
        env:
          CI: ${{ secrets.CI }}

      - name: Generate Prisma Client
        run: pnpm prisma:generate:prod
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: Build Project # NestJS 빌드
        run: pnpm build # pnpm을 사용하여 빌드
        env:
          NODE_ENV: ${{ secrets.NODE_ENV }} # 환경 변수 설정
          CI: ${{ secrets.CI }} # CI 환경 변수 설정

      - name: Upload Build Artifact # 빌드 결과물 업로드
        uses: actions/upload-artifact@v4 # actions/upload-artifact 레포지토리의 v4 버전 사용
        with:
          name: build # 업로드할 파일 이름
          path: |
            dist
            package.json
            pnpm-lock.yaml
            prisma
            node_modules/.prisma/client

      - name: Configure SSH # SSH 설정
        run: |
          mkdir -p ~/.ssh/
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_${{ secrets.EC2_KEY_PAIR_TYPE }}
          chmod 600 ~/.ssh/id_${{ secrets.EC2_KEY_PAIR_TYPE }}
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Validate Environment Variables # 환경 변수 검증
        run: |
          if [ -z "${{ secrets.NODE_ENV }}" ]; then
            echo "NODE_ENV is not set"
            exit 1
          fi
          if [ -z "${{ secrets.DATABASE_URL }}" ]; then
            echo "DATABASE_URL is not set"
            exit 1
          fi
          if [ -z "${{ secrets.EC2_SSH_KEY }}" ]; then
            echo "EC2_SSH_KEY is not set"
            exit 1
          fi
          if [ -z "${{ secrets.EC2_KEY_PAIR_TYPE }}" ]; then
            echo "EC2_KEY_PAIR_TYPE is not set"
            exit 1
          fi
          if [ -z "${{ secrets.EC2_USERNAME }}" ]; then
            echo "EC2_USERNAME is not set"
            exit 1
          fi
          if [ -z "${{ secrets.EC2_HOST }}" ]; then
            echo "EC2_HOST is not set"
            exit 1
          fi
          if [ -z "${{ secrets.DEPLOY_VERIFY_KEY }}" ]; then
            echo "DEPLOY_VERIFY_KEY is not set"
            exit 1
          fi
          if [ -z "${{ secrets.GPG_PASSPHRASE }}" ]; then
            echo "GPG_PASSPHRASE is not set"
            exit 1
          fi

      - name: Create and mask env file # .env 파일 생성, 마스킹 및 전송
        env:
          NODE_ENV: ${{ secrets.NODE_ENV }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          EC2_KEY_PAIR_TYPE: ${{ secrets.EC2_KEY_PAIR_TYPE }}
          EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          DEPLOY_VERIFY_KEY: ${{ secrets.DEPLOY_VERIFY_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          GIT_COMMIT_SHA: ${{ github.sha }}
        run: |
          # 환경 변수와 "키=값" 형태 모두 마스킹
          echo "::add-mask::${NODE_ENV}"
          echo "::add-mask::NODE_ENV=${NODE_ENV}"
          echo "::add-mask::${DATABASE_URL}"
          echo "::add-mask::DATABASE_URL=${DATABASE_URL}"
          echo "::add-mask::${EC2_KEY_PAIR_TYPE}"
          echo "::add-mask::EC2_KEY_PAIR_TYPE=${EC2_KEY_PAIR_TYPE}"
          echo "::add-mask::${EC2_USERNAME}"
          echo "::add-mask::EC2_USERNAME=${EC2_USERNAME}"
          echo "::add-mask::${EC2_HOST}"
          echo "::add-mask::EC2_HOST=${EC2_HOST}"
          echo "::add-mask::${DEPLOY_VERIFY_KEY}"
          echo "::add-mask::DEPLOY_VERIFY_KEY=${DEPLOY_VERIFY_KEY}"
          echo "::add-mask::${GPG_PASSPHRASE}"
          echo "::add-mask::GPG_PASSPHRASE=${GPG_PASSPHRASE}"
          echo "::add-mask::${GIT_COMMIT_SHA}"
          echo "::add-mask::GIT_COMMIT_SHA=${GIT_COMMIT_SHA}"

          # .env 파일 생성
          echo "NODE_ENV=${NODE_ENV}" > .env
          echo "DATABASE_URL=${DATABASE_URL}" >> .env
          echo "DEPLOY_VERIFY_KEY=${DEPLOY_VERIFY_KEY}" >> .env

          # 파일 암호화 및 전송
          cat .env | gpg --symmetric --batch --passphrase "${{ secrets.GPG_PASSPHRASE }}" > .env.gpg
          scp -i ~/.ssh/id_${{ secrets.EC2_KEY_PAIR_TYPE }} .env.gpg ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/backend/

      - name: Setup PM2 Config # PM2 설정 및 전송
        run: |
          echo "module.exports = {
            apps: [{
              name: 'snack25-be',
              script: 'dist/main.js',
              instances: 'max',
              autorestart: true,
              watch: false,
              max_memory_restart: '1G',
              env: {
                NODE_ENV: 'production'
              }
            }]
          }" > ecosystem.config.js
          scp -i ~/.ssh/id_${{ secrets.EC2_KEY_PAIR_TYPE }} ecosystem.config.js ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/backend/

      - name: Backup current deployment
        run: |
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'cd ~/backend && \
          if [ -d dist ] || [ -d node_modules ]; then \
            backup_file="backup-$(date +%Y%m%d_%H%M%S).tar.gz" && \
            echo "Creating backup: $backup_file" && \
            tar -czf "$backup_file" dist node_modules || true; \
          else \
            echo "No existing deployment to backup"; \
          fi'

      - name: Deploy to EC2 # EC2로 배포
        timeout-minutes: 5 # 타임아웃 시간 설정
        env:
          KEY_PAIR_TYPE: ${{ secrets.EC2_KEY_PAIR_TYPE }}
          USERNAME: ${{ secrets.EC2_USERNAME }}
          HOST: ${{ secrets.EC2_HOST }}
          SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_KEY }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          DEPLOY_VERIFY_KEY: ${{ secrets.DEPLOY_VERIFY_KEY }}
          GIT_COMMIT_SHA: ${{ github.sha }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          {
            echo "Deploying to $HOST"
            echo "Starting deployment to EC2..."
            echo "Creating .env file..."
            echo "DATABASE_URL=${DATABASE_URL}" > .env
            scp -i ~/.ssh/id_${{ secrets.EC2_KEY_PAIR_TYPE }} -r dist package.json pnpm-lock.yaml prisma ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/backend/
            scp -i ~/.ssh/id_${{ secrets.EC2_KEY_PAIR_TYPE }} .env ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/backend/
            scp -i ~/.ssh/id_${{ secrets.EC2_KEY_PAIR_TYPE }} ecosystem.config.js ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/backend/
            ssh -i ~/.ssh/id_${{ secrets.EC2_KEY_PAIR_TYPE }} ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'cd ~/backend && \
              source ~/.nvm/nvm.sh && nvm use 22 && corepack enable && \
              pm2 stop all || true && pm2 delete all || true && \
              pnpm install --prod --ignore-scripts && \
              pnpm prisma:generate:prod && \
              pnpm prisma:deploy:prod && \
              pm2 start ecosystem.config.js --env production'
          } 2>&1 | tee deploy.log
          echo "Deploy to EC2 작업 완료"

      - name: Rollback on Failure # 배포 실패 시 롤백
        if: failure()
        run: |
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'cd ~/backend && {
            if ls backup-*.tar.gz 1> /dev/null 2>&1; then
              echo "Backup found, restoring..."
              pm2 stop all || true && pm2 delete all || true
              tar -xzf backup-*.tar.gz
              pm2 start ecosystem.config.js --env production
              echo "Rollback complete."
            else
              echo "No backup found, cannot rollback."
            fi
          }'

      - name: Verify Deployment # 배포 검증
        env:
          HOST: ${{ secrets.EC2_HOST }}
          DEPLOY_VERIFY_KEY: ${{ secrets.DEPLOY_VERIFY_KEY }}
          GIT_COMMIT_SHA: ${{ github.sha }}
        run: |
          echo "배포 검증을 시작합니다..."
          # 서버가 완전히 시작할 때까지 잠시 대기
          sleep 10

          # 헬스 체크 엔드포인트로 요청 보내기 (X-Deploy-Key 헤더 포함)
          RESPONSE=$(curl -s -w "\n%{http_code}" -H "X-Deploy-Key: ${DEPLOY_VERIFY_KEY}" http://${HOST}:4000/health)

          # HTTP 상태 코드와 응답 본문 분리
          HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$ d')

          echo "HTTP 상태 코드: ${HTTP_STATUS}"

          # HTTP 상태 코드가 200인지 확인
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "오류: 배포 검증 실패. 서버가 정상적으로 응답하지 않습니다."
            echo "응답: ${RESPONSE_BODY}"
            exit 1
          fi

          # 응답에 "status": "ok"가 포함되어 있는지 확인
          if ! echo "$RESPONSE_BODY" | grep -q '"status":"ok"'; then
            echo "오류: 배포 검증 실패. 서버 상태가 정상이 아닙니다."
            echo "응답: ${RESPONSE_BODY}"
            exit 1
          fi

          # 응답에 올바른 GIT_COMMIT_SHA가 포함되어 있는지 확인
          if ! echo "$RESPONSE_BODY" | grep -q "\"version\":\"$GIT_COMMIT_SHA\""; then
            echo "경고: 배포된 버전이 예상과 다를 수 있습니다."
            echo "예상 버전: ${GIT_COMMIT_SHA}"
            echo "응답: ${RESPONSE_BODY}"
            # 버전 불일치는 경고만 표시하고 배포를 실패로 처리하지 않음
          fi

          echo "✅ 배포 검증 성공: 애플리케이션이 정상적으로 실행 중입니다."

permissions:
  contents: read # 레포지토리 내용 읽기 권한
  deployments: write # 배포 권한
  id-token: write # OIDC 인증을 위해 추가 필요

concurrency:
  group: production_environment # 동시성 그룹 설정
  cancel-in-progress: false # 진행 중인 작업 취소 여부
